import os
import os.path
import numpy as np
from matplotlib import pyplot as plt
from collections import defaultdict


class Data(object):
    def __init__(self, filename, label=None):
        self.filename = filename

        if label is None:
            self.type = 'simple no agg' if 'dqzj2' in filename \
                else 'simple agg' if 'pos09' in filename \
                else 'complex agg' if 'o9di2' in filename \
                else None

            self.penetration = 0.05 if '0p05' in filename \
                        else 0.1 if '0p1' in filename \
                        else 0.2 if '0p2' in filename \
                        else 0.4 if '0p4' in filename \
                        else None

            self.eval_penetration = 0.05 if '0.05' in filename \
                            else 0.1 if '0.1' in filename \
                            else 0.2 if '0.2' in filename \
                            else 0.4 if '0.4' in filename \
                            else None

            assert(None not in [self.type, self.penetration, self.eval_penetration])

            self.transferred = self.penetration != self.eval_penetration

            self.label = f'{self.type} {self.penetration * 100} %'
            if self.penetration != self.eval_penetration:
                self.label = f'{self.label} (eval at {self.eval_penetration * 100} %)'
        else:
            self.label = label

        self.load_data()

    def load_data(self):
        """Load data from a bottleneck_outflow file generated by bottleneck_results.py."""
        try:
            outflow_arr = np.loadtxt(self.filename, delimiter=', ')
        except ValueError:
            outflow_arr = np.loadtxt(self.filename, delimiter=',')

        unique_inflows = sorted(list(set(outflow_arr[:, 0])))
        inflows = outflow_arr[:, 0]
        outflows = outflow_arr[:, 1]

        sorted_outflows = {inflow: [] for inflow in unique_inflows}
        for inflow, outflow in zip(inflows, outflows):
            sorted_outflows[inflow].append(outflow)

        mean_outflows = np.asarray([np.mean(sorted_outflows[inflow]) for inflow in unique_inflows])
        std_outflows = np.asarray([np.std(sorted_outflows[inflow]) for inflow in unique_inflows])

        self.unique_inflows = unique_inflows
        self.mean_outflows = mean_outflows
        self.std_outflows = std_outflows


def init_plt_figure(xlabel, ylabel):
    plt.figure(figsize=(10, 5))
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.tick_params(labelsize=10)
    plt.rcParams['xtick.minor.size'] = 10
    plt.minorticks_on()
    plt.grid()

def save_plt_figure(filename, save_dir='fig'):
    if not os.path.exists(save_dir):
        os.makedirs(save_dir)
    filename = filename.replace('.', 'p')
    print('Generated', filename)
    plt.legend(loc="lower left")
    plt.title(filename)
    plt.savefig(fname=os.path.join(save_dir, filename))

def generate_outflow_inflow_graphs(data_rl, data_baseline):
    """Outflow as a function of inflow."""
    def plot_outflow_inflow(data, std=True):
        if isinstance(data, list):
            for d in data:
                plot_outflow_inflow(d)
            return
        plt.plot(data.unique_inflows, data.mean_outflows, linewidth=2, label=data.label) #, color='orange')
        if std:
            plt.fill_between(data.unique_inflows, data.mean_outflows - data.std_outflows,
                             data.mean_outflows + data.std_outflows, alpha=0.25) #, color='orange')

    # outflow as a function of inflow (by penetration)
    for penetration in [0.05, 0.1, 0.2, 0.4]:
        for eval_penetration in [0.05, 0.1, 0.2, 0.4]:
            init_plt_figure('Outflow' + r'$ \ \frac{vehs}{hour}$', 'Inflow' + r'$ \ \frac{vehs}{hour}$')
            for data in data_rl:
                if data.penetration == penetration and data.eval_penetration == eval_penetration:
                    plot_outflow_inflow(data)
            plot_outflow_inflow(data_baseline)
            save_plt_figure(f'outflow_inflow_{penetration}_eval_{eval_penetration}', save_dir='figs/outflow_inflow_all')

    # outflow as a function of inflow (by state type)
    for state_type in ['simple no agg', 'simple agg', 'complex agg']:
        init_plt_figure('Outflow' + r'$ \ \frac{vehs}{hour}$', 'Inflow' + r'$ \ \frac{vehs}{hour}$')
        for data in data_rl:
            if data.type == state_type and not data.transferred:
                plot_outflow_inflow(data)
        plot_outflow_inflow(data_baseline)
        save_plt_figure(f'outflow_inflow_{state_type.replace(" ", "_")}', save_dir='figs/outflow_inflow_no_transfer')


def generate_outflow2400_penetration_graphs(data_rl, data_baseline):
    """Outflow at 2400 inflow as a function of penetration."""
    for state_type in ['simple no agg', 'simple agg', 'complex agg']:
        init_plt_figure('Outflow' + r'$ \ \frac{vehs}{hour}$', 'Penetration' + r'$ \ \%$')
        all_data = []
        for data in data_rl:
            if data.type == state_type and not data.transferred:
                all_data.append(data)
        assert(list(set([d.unique_inflows[20] for d in all_data]))[0] == 2400.0)
        mean_outflows = np.array([d.mean_outflows[20] for d in all_data])
        std_outflows = np.array([d.std_outflows[20] for d in all_data])
        penetrations = np.array([100 * d.penetration for d in all_data], dtype=np.int)
        idx = np.argsort(penetrations)

        plt.plot(penetrations[idx], mean_outflows[idx], linewidth=2, label='?') #, color='orange')
        plt.fill_between(penetrations[idx], mean_outflows[idx] - std_outflows[idx],
                         mean_outflows[idx] + std_outflows[idx], alpha=0.25) #, color='orange')

        save_plt_figure(f'outflow2400_penetration_{state_type.replace(" ", "_")}', save_dir='figs/outflow2400_penetration')


def get_outflows_at_3500_inflow(data_rl):
    """Print outflows at 3500 inflow as a function of penetration and state space."""
    data_print = defaultdict(dict)

    for state_type in ['simple no agg', 'simple agg', 'complex agg']:
        all_data = []
        for data in data_rl:
            if data.type == state_type and not data.transferred:
                all_data.append(data)
        assert(list(set([d.unique_inflows[31] for d in all_data]))[0] == 3500.0)
        mean_outflows = np.array([d.mean_outflows[31] for d in all_data])
        std_outflows = np.array([d.std_outflows[31] for d in all_data])
        penetrations = np.array([100 * d.penetration for d in all_data], dtype=np.int)

        print(f'\nState space: {state_type}')
        for i in np.argsort(penetrations):
            print(f'\tpenetration={penetrations[i]}%; outflow(3500)={mean_outflows[i]}; std_outflow(3500)={std_outflows[i]}')
            data_print[state_type][penetrations[i]] = (mean_outflows[i], std_outflows[i])
    
    if True:
        # print in latex table syntax
        for penetration in [5, 10, 20, 40]:
            print(fr'{penetration}\%', end=' ')
            for state_type in ['simple no agg', 'simple agg', 'complex agg']:
                mean_outflow, std_outflow = data_print[state_type][penetration]
                print(f'& {int(mean_outflow)} ({int(std_outflow)})', end=' ')
            print(r'\\ \hline')


if __name__ == '__main__':
    generate_plots = False

    # load data
    data_rl = []
    for (dirpath, dirnames, filenames) in os.walk('./data'):
        for filename in filenames:
            if filename.startswith('bottleneck_outflow'):
                data_rl.append(Data(filename=os.path.join(dirpath, filename)))
    type_order = {'simple no agg': 0, 'simple agg': 1, 'complex agg': 2}
    data_rl.sort(key=lambda x: [x.penetration, x.eval_penetration, type_order[x.type], x.label])
        
    data_baseline = []
    data_baseline.append(Data(filename='data/alinea_vs_controller/alinea.csv', label='ALINEA'))
    data_baseline.append(Data(filename='data/alinea_vs_controller/human.csv', label='human'))
    data_baseline.append(Data(filename='data/alinea_vs_controller/p40.csv', label='40% hand designed'))

    print('Data loaded:', [d.label for d in data_rl + data_baseline])
    print(f'{len(data_rl)} RL data + {len(data_baseline)} baseline data')

    if generate_plots:
        # generate graphs
        generate_outflow_inflow_graphs(data_rl, data_baseline)
        generate_outflow2400_penetration_graphs(data_rl, data_baseline)
    else:
        # print stuff
        get_outflows_at_3500_inflow(data_rl)
